<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title></title>
    <meta name="generator" content="LibreOffice 7.6.4.1 (Linux)" />
    <meta name="created" content="00:00:00" />
    <meta name="changed" content="00:00:00" />
    <style type="text/css">
@page {
        size: 8.27in 11.69in; margin: 0.79in
    }
        p {
            line-height: 115%;
            margin-bottom: 0.1in;
            background: transparent
        }
        pre {
            background: transparent
        }
        pre.western {
            font-family: "Liberation Mono", monospace;
            font-size: 10pt
        }
        pre.cjk {
            font-family: "NSimSun", monospace;
            font-size: 10pt
        }
        pre.ctl {
            font-family: "Liberation Mono", monospace;
            font-size: 10pt
        }
    </style>
</head>
<body lang="en-US" link="#000080" vlink="#800000" dir="ltr">
    <pre class="western">&lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
        &lt;title&gt;Pope Demon Hunter&lt;/title&gt;
        &lt;style&gt;
        body {
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        font-family: 'Arial', sans-serif;
        color: white;
        overflow: hidden;
        touch-action: none;
        }

        #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
        }

        #gameCanvas {
        background: linear-gradient(180deg, #2c1810, #1a0f0a);
        display: block;
        }

        #ui {
        position: absolute;
        top: 60px;
        left: 10px;
        z-index: 150;
        font-size: 16px;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        display: flex;
        flex-direction: column;
        gap: 8px;
        }

        #controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        }

        #joystick {
        width: 120px;
        height: 120px;
        background: rgba(255,255,255,0.1);
        border: 3px solid rgba(255,255,255,0.3);
        border-radius: 50%;
        position: relative;
        touch-action: none;
        }

        #joystickKnob {
        width: 40px;
        height: 40px;
        background: rgba(255,215,0,0.8);
        border: 2px solid rgba(255,255,255,0.5);
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 10px rgba(255,215,0,0.5);
        }

        #skillBar {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translate(-50%, 0);
        background: rgba(0,0,0,0.8);
        border: 2px solid gold;
        border-radius: 8px;
        padding: 5px;
        z-index: 200;
        display: flex;
        gap: 10px;
        }

        .skill {
        width: 28px;
        height: 28px;
        border: 2px solid #666;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.3s;
        text-align: center;
        position: relative;
        }

        .skill:hover, .skill:active {
        box-shadow: 0 0 8px rgba(255,215,0,0.6);
        }

        .skill-level {
        position: absolute;
        bottom: 1px;
        right: 1px;
        font-size: 6px;
        color: #ffffff;
        text-shadow: 1px 1px 1px #000000;
        }

        .skill.available {
        border-color: gold;
        background: rgba(255,215,0,0.2);
        }

        .skill.maxed {
        border-color: #4CAF50;
        background: rgba(76,175,80,0.3);
        }

        .skill.disabled {
        opacity: 0.3;
        cursor: not-allowed;
        }

        #skillPoints {
        position: absolute;
        top: 60px;
        right: 10px;
        font-size: 16px;
        color: gold;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        text-align: right;
        z-index: 150;
        }
        &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;div id=&quot;gameContainer&quot;&gt;
        &lt;canvas id=&quot;gameCanvas&quot;&gt;&lt;/canvas&gt;

        &lt;div id=&quot;ui&quot;&gt;
        &lt;div&gt;Health: &lt;span id=&quot;health&quot;&gt;120&lt;/span&gt;&lt;/div&gt;
        &lt;div&gt;Score: &lt;span id=&quot;score&quot;&gt;0&lt;/span&gt;&lt;/div&gt;
        &lt;div&gt;Level: &lt;span id=&quot;level&quot;&gt;1&lt;/span&gt;&lt;/div&gt;
        &lt;div&gt;XP: &lt;span id=&quot;xp&quot;&gt;0&lt;/span&gt; / &lt;span id=&quot;xpNeeded&quot;&gt;150&lt;/span&gt;&lt;/div&gt;
        &lt;div&gt;Class: &lt;span id=&quot;classLevel&quot;&gt;Pilgrim&lt;/span&gt;&lt;/div&gt;
        &lt;/div&gt;

        &lt;div id=&quot;skillPoints&quot;&gt;Skill Points: &lt;span id=&quot;availablePoints&quot;&gt;0&lt;/span&gt;&lt;/div&gt;

        &lt;div id=&quot;controls&quot;&gt;
        &lt;div id=&quot;joystick&quot;&gt;
        &lt;div id=&quot;joystickKnob&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;/div&gt;

        &lt;div id=&quot;skillBar&quot;&gt;
        &lt;div class=&quot;skill&quot; data-skill=&quot;holyWater&quot; title=&quot;Holy Water Blessing: Slows enemies&quot;&gt;
        &lt;div&gt;üíß&lt;/div&gt;
        &lt;div class=&quot;skill-level&quot;&gt;L0&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;skill&quot; data-skill=&quot;summa&quot; title=&quot;Summa Theologica: Larger projectiles&quot;&gt;
        &lt;div&gt;üìñ&lt;/div&gt;
        &lt;div class=&quot;skill-level&quot;&gt;L0&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;skill&quot; data-skill=&quot;rosary&quot; title=&quot;Combat Rosary: Faster fire rate&quot;&gt;
        &lt;div&gt;üìø&lt;/div&gt;
        &lt;div class=&quot;skill-level&quot;&gt;L0&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;skill&quot; data-skill=&quot;speed&quot; title=&quot;Wings of Seraphim: Faster movement&quot;&gt;
        &lt;div&gt;üïäÔ∏è&lt;/div&gt;
        &lt;div class=&quot;skill-level&quot;&gt;L0&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;skill&quot; data-skill=&quot;health&quot; title=&quot;Sacred Heart: More health&quot;&gt;
        &lt;div&gt;‚úùÔ∏è&lt;/div&gt;
        &lt;div class=&quot;skill-level&quot;&gt;L0&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;skill&quot; data-skill=&quot;damage&quot; title=&quot;Sword of the Spirit: Stronger attacks&quot;&gt;
        &lt;div&gt;‚öîÔ∏è&lt;/div&gt;
        &lt;div class=&quot;skill-level&quot;&gt;L0&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;skill&quot; data-skill=&quot;multishot&quot; title=&quot;Trinity Strike: More projectiles&quot;&gt;
        &lt;div&gt;üî±&lt;/div&gt;
        &lt;div class=&quot;skill-level&quot;&gt;L0&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;skill&quot; data-skill=&quot;healing&quot; title=&quot;Grace of the Virgin: Passive healing&quot;&gt;
        &lt;div&gt;‚ú®&lt;/div&gt;
        &lt;div class=&quot;skill-level&quot;&gt;L0&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;skill&quot; data-skill=&quot;divineJudgment&quot; title=&quot;Divine Judgment: AoE incineration&quot;&gt;
        &lt;div&gt;‚úùÔ∏è&lt;/div&gt;
        &lt;div class=&quot;skill-level&quot;&gt;L0&lt;/div&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;/div&gt;

        &lt;script&gt;
        // Game state
        const game = {
        canvas: null,
        ctx: null,
        width: 0,
        height: 0,
        centerX: 0,
        centerY: 0,
        player: {
        x: 0,
        y: 0,
        angle: 0,
        speed: 4.5,
        health: 120,
        maxHealth: 120,
        size: 20,
        invulnerable: 0,
        pulse: 0,
        baseY: 0
        },
        projectiles: [],
        enemies: [],
        powerUps: [],
        particles: [],
        textOverlays: [],
        score: 0,
        level: 1,
        xp: 0,
        xpNeeded: 150,
        skillPoints: 0,
        spentSkillPoints: 0,
        classLevel: 'Pilgrim',
        skills: {
        holyWater: 0,
        summa: 0,
        rosary: 0,
        speed: 0,
        health: 0,
        damage: 0,
        multishot: 0,
        healing: 0,
        divineJudgment: 0,
        divineJudgmentCooldown: 0
        },
        paused: false,
        lastEnemySpawn: 0,
        lastPowerUpSpawn: 0,
        fireRate: 166,
        lastShot: 0,
        powerUpActive: null,
        powerUpDuration: 0,
        lastFrameTime: performance.now(),
        michael: null,
        screenShake: { intensity: 0, duration: 0 },
        divineJudgment: null,
        startupMessage: { text: 'Defend the Faith!', life: 120 }
        };

        // Input handling
        const input = {
        joystick: { x: 0, y: 0, active: false }
        };

        // Math cache
        const { sqrt, cos, sin, atan2, random, PI } = Math;
        const TWO_PI = PI * 2;

        // Initialize game
        function init() {
        try {
        game.canvas = document.getElementById('gameCanvas');
        if (!game.canvas) throw new Error('Canvas not found');
        game.ctx = game.canvas.getContext('2d');
        if (!game.ctx) throw new Error('Canvas context not available');

        resize();
        window.addEventListener('resize', resize);

        setupControls();
        setupSkillBar();

        game.player.x = game.centerX;
        game.player.y = game.centerY;
        game.player.baseY = game.centerY;

        for (let i = 0; i &lt; 2; i++) {
        spawnEnemy();
        }

        console.log('Game initialized:', { player: game.player, enemies: game.enemies.length });
        gameLoop();
        } catch (e) {
        console.error('Initialization error:', e);
        }
        }

        function resize() {
        game.width = window.innerWidth;
        game.height = window.innerHeight;
        game.centerX = game.width / 2;
        game.centerY = game.height / 2;
        game.canvas.width = game.width;
        game.canvas.height = game.height;
        }

        function setupControls() {
        const joystick = document.getElementById('joystick');
        const joystickKnob = document.getElementById('joystickKnob');

        function handleJoystickMove(clientX, clientY) {
        const rect = joystick.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        let deltaX = clientX - centerX;
        let deltaY = clientY - centerY;

        const distance = sqrt(deltaX * deltaX + deltaY * deltaY);
        const maxDistance = 40;

        if (distance &gt; maxDistance) {
        deltaX = (deltaX / distance) * maxDistance;
        deltaY = (deltaY / distance) * maxDistance;
        }

        input.joystick.x = deltaX / maxDistance;
        input.joystick.y = deltaY / maxDistance;

        joystickKnob.style.transform = `translate(${deltaX - 20}px, ${deltaY - 20}px)`;
        }

        joystick.addEventListener('touchstart', (e) =&gt; {
        e.preventDefault();
        input.joystick.active = true;
        handleJoystickMove(e.touches[0].clientX, e.touches[0].clientY);
        });

        joystick.addEventListener('touchmove', (e) =&gt; {
        e.preventDefault();
        if (input.joystick.active) {
        handleJoystickMove(e.touches[0].clientX, e.touches[0].clientY);
        }
        });

        joystick.addEventListener('touchend', (e) =&gt; {
        e.preventDefault();
        input.joystick.active = false;
        input.joystick.x = 0;
        input.joystick.y = 0;
        joystickKnob.style.transform = 'translate(-50%, -50%)';
        });
        }

        function setupSkillBar() {
        const skills = document.querySelectorAll('.skill');

        skills.forEach(skill =&gt; {
        skill.addEventListener('click', () =&gt; {
        const skillName = skill.dataset.skill;
        purchaseSkill(skillName);
        });
        });

        updateSkillBar();
        }

        function updateSkillBar() {
        document.getElementById('availablePoints').textContent = game.skillPoints;

        const skills = document.querySelectorAll('.skill');
        skills.forEach(skill =&gt; {
        const skillName = skill.dataset.skill;
        const level = game.skills[skillName];
        skill.className = 'skill';

        const levelDisplay = skill.querySelector('.skill-level');
        levelDisplay.textContent = `L${level}`;

        let tooltip;
        switch(skillName) {
        case 'holyWater': tooltip = `Holy Water Blessing: ${5 * level}% Slow`; break;
        case 'summa': tooltip = `Summa Theologica: +${12.5 * level}% Proj Size`; break;
        case 'rosary': tooltip = `Combat Rosary: ${Math.round((1 - Math.max(50, 166 - level * 8)/166) * 100)}% Fire Rate`; break;
        case 'speed': tooltip = `Wings of Seraphim: +${0.75 * level} Speed`; break;
        case 'health': tooltip = `Sacred Heart: +${50 * level} Max Health`; break;
        case 'damage': tooltip = `Sword of the Spirit: +${25 * level}% Damage`; break;
        case 'multishot': tooltip = `Trinity Strike: ${Math.floor(1 + level * 0.5)} Projectiles`; break;
        case 'healing': tooltip = `Grace of the Virgin: ${0.05 * level} HP/s`; break;
        case 'divineJudgment': tooltip = `Divine Judgment: ${10 * level} AoE Damage, ${200 + level * 10}px Radius`; break;
        }
        skill.title = tooltip;

        if (level &gt;= 10) {
        skill.classList.add('maxed');
        } else if (game.skillPoints &gt; 0 &amp;&amp; (skillName !== 'divineJudgment' || game.skills.divineJudgmentCooldown &lt;= 0)) {
        skill.classList.add('available');
        } else if (skillName === 'divineJudgment' &amp;&amp; game.skills.divineJudgmentCooldown &gt; 0) {
        skill.classList.add('disabled');
        }
        });
        }

        function purchaseSkill(skillName) {
        if (game.skillPoints &gt; 0 &amp;&amp; game.skills[skillName] &lt; 10) {
        if (skillName === 'divineJudgment' &amp;&amp; game.skills.divineJudgmentCooldown &gt; 0) {
        return;
        }
        game.skills[skillName]++;
        game.skillPoints--;
        game.spentSkillPoints++;
        applySkillEffect(skillName);
        updateClassLevel();
        updateSkillBar();
        }
        }

        function updateClassLevel() {
        const points = game.spentSkillPoints;
        let newClass;
        if (points &gt;= 40) newClass = 'Doctor of the Church';
        else if (points &gt;= 30) newClass = 'Martyr';
        else if (points &gt;= 20) newClass = 'Apostle';
        else if (points &gt;= 10) newClass = 'Disciple';
        else newClass = 'Pilgrim';

        if (newClass !== game.classLevel) {
        game.classLevel = newClass;
        addTextOverlay(`Promoted to ${newClass}!`, '#ffd700');
        }
        updateUI();
        }

        function addTextOverlay(text, color) {
        const index = game.textOverlays.length;
        game.textOverlays.push({
        text: text,
        x: game.centerX,
        y: game.centerY - 50 * index,
        life: 180,
        color: color,
        opacity: 1,
        scale: 1
        });
        }

        function applySkillEffect(skillName) {
        const level = game.skills[skillName];
        const gameLevel = game.level;
        const shakeIntensity = gameLevel &gt;= 7 ? 8 : gameLevel &gt;= 4 ? 4 : 0;
        if (shakeIntensity &gt; 0) {
        game.screenShake = { intensity: shakeIntensity, duration: 50 };
        }

        const particleCount = gameLevel &gt;= 7 ? 20 : gameLevel &gt;= 4 ? 15 : 10;
        game.player.pulse = 12;

        let shape;
        switch(skillName) {
        case 'speed':
        shape = 'feather';
        createParticles(game.player.x, game.player.y, '#ffffff', particleCount, 3, shape);
        addTextOverlay(`Wings of Seraphim L${level}! +${0.75 * level} Speed`, '#ffffff');
        game.player.speed = 4.5 + level * 0.75;
        break;
        case 'health':
        shape = 'heart';
        game.player.maxHealth += 50;
        game.player.health = game.player.maxHealth;
        createParticles(game.player.x, game.player.y, '#ff3333', particleCount, 3, shape);
        if (gameLevel &gt;= 4) {
        game.ctx.fillStyle = 'rgba(255, 51, 51, 0.5)';
        game.ctx.fillRect(0, 0, game.width, game.height);
        }
        addTextOverlay(`Sacred Heart L${level}! +${50 * level} Max Health`, '#ff3333');
        break;
        case 'damage':
        shape = 'sword';
        createParticles(game.player.x, game.player.y, '#ff4500', particleCount, 3, shape);
        addTextOverlay(`Sword of the Spirit L${level}! +${25 * level}% Damage`, '#ff4500');
        break;
        case 'holyWater':
        shape = 'droplet';
        createParticles(game.player.x, game.player.y, '#00b7eb', particleCount, 3, shape);
        addTextOverlay(`Holy Water Blessing L${level}! ${5 * level}% Slow`, '#00b7eb');
        break;
        case 'summa':
        shape = 'book';
        createParticles(game.player.x, game.player.y, '#ff8c00', particleCount, 3, shape);
        addTextOverlay(`Summa Theologica L${level}! +${12.5 * level}% Proj Size`, '#ff8c00');
        break;
        case 'rosary':
        shape = 'bead';
        game.fireRate = Math.max(50, 166 - level * 8);
        createParticles(game.player.x, game.player.y, '#f0e68c', particleCount, 3, shape);
        addTextOverlay(`Combat Rosary L${level}! ${Math.round((1 - game.fireRate/166) * 100)}% Fire Rate`, '#f0e68c');
        break;
        case 'multishot':
        shape = 'trident';
        createParticles(game.player.x, game.player.y, '#ffd700', particleCount, 3, shape);
        addTextOverlay(`Trinity Strike L${level}! ${Math.floor(1 + level * 0.5)} Projectiles`, '#ffd700');
        break;
        case 'healing':
        shape = 'star';
        createParticles(game.player.x, game.player.y, '#ff69b4', particleCount, 3, shape);
        addTextOverlay(`Grace of the Virgin L${level}! ${0.05 * level} HP/s`, '#ff69b4');
        break;
        case 'divineJudgment':
        shape = 'cross';
        game.skills.divineJudgmentCooldown = 1800;
        game.divineJudgment = {
        phase: 'pause',
        timer: 0,
        duration: 30,
        damage: 10 * level,
        crossY: game.player.y - 150
        };
        console.log('Divine Judgment activated:', game.divineJudgment);
        createParticles(game.player.x, game.player.y, '#ffffff', particleCount, 3, shape);
        addTextOverlay(`Divine Judgment L${level}! ${10 * level} AoE Incineration`, '#ffd700');
        break;
        }
        }

        function update(now) {
        if (game.paused) return;

        let deltaTime = (now - game.lastFrameTime) / 1000;
        if (isNaN(deltaTime) || deltaTime &gt; 0.016) deltaTime = 0.016;
        game.lastFrameTime = now;

        if (game.screenShake.duration &gt; 0) {
        game.screenShake.duration -= deltaTime * 60;
        } else {
        game.screenShake.intensity = 0;
        }

        game.textOverlays.forEach((overlay, index) =&gt; {
        overlay.life -= deltaTime * 60;
        overlay.opacity = overlay.life / 180;
        overlay.scale += deltaTime * 1.1;
        if (overlay.life &lt;= 0) {
        game.textOverlays.splice(index, 1);
        }
        });

        if (game.startupMessage) {
        game.startupMessage.life -= deltaTime * 60;
        if (game.startupMessage.life &lt;= 0) {
        game.startupMessage = null;
        }
        }

        if (game.divineJudgment) {
        updateDivineJudgment(deltaTime);
        }

        if (!game.divineJudgment || game.divineJudgment.phase === 'impact') {
        game.player.x += input.joystick.x * game.player.speed * deltaTime * 60;
        game.player.y += input.joystick.y * game.player.speed * deltaTime * 60;

        game.player.x = Math.max(game.player.size, Math.min(game.width - game.player.size, game.player.x));
        game.player.y = Math.max(game.player.size, Math.min(game.height - game.player.size, game.player.y));

        game.player.baseY = game.player.y;

        if (input.joystick.x !== 0 || input.joystick.y !== 0) {
        game.player.angle = atan2(input.joystick.y, input.joystick.x);
        }
        }

        if (game.player.invulnerable &gt; 0) {
        game.player.invulnerable -= deltaTime * 60;
        }

        if (game.player.pulse &gt; 0) {
        game.player.pulse -= deltaTime * 60;
        }

        if (game.skills.divineJudgmentCooldown &gt; 0) {
        game.skills.divineJudgmentCooldown -= deltaTime * 60;
        if (game.skills.divineJudgmentCooldown &lt;= 0) {
        updateSkillBar();
        }
        }

        if (!game.divineJudgment || game.divineJudgment.phase === 'impact') {
        if (game.michael) {
        updateMichael(deltaTime);
        }

        if (now - game.lastShot &gt; game.fireRate) {
        shootAtClosest();
        game.lastShot = now;
        }

        const spawnRate = game.level &lt;= 3 ? 600 : Math.max(300, 1000 - (game.level * 100));
        if (now - game.lastEnemySpawn &gt; spawnRate &amp;&amp; !game.michael &amp;&amp; !game.divineJudgment) {
        spawnEnemy();
        game.lastEnemySpawn = now;
        }

        if (now - game.lastPowerUpSpawn &gt; 20000 + random() * 15000) {
        spawnPowerUp();
        game.lastPowerUpSpawn = now;
        }

        game.projectiles.forEach((proj, index) =&gt; {
        proj.x += cos(proj.angle) * proj.speed * deltaTime * 60;
        proj.y += sin(proj.angle) * proj.speed * deltaTime * 60;

        if (proj.x &lt; 0 || proj.x &gt; game.width || proj.y &lt; 0 || proj.y &gt; game.height) {
        game.projectiles.splice(index, 1);
        }
        });

        game.powerUps.forEach((powerUp, index) =&gt; {
        const dx = game.player.x - powerUp.x;
        const dy = game.player.y - powerUp.y;
        const distance = sqrt(dx * dx + dy * dy);

        if (distance &lt; game.player.size + powerUp.size) {
        activatePowerUp(powerUp.type);
        game.powerUps.splice(index, 1);
        }
        });

        if (game.powerUpActive &amp;&amp; game.powerUpDuration &gt; 0) {
        game.powerUpDuration -= deltaTime * 60;
        if (game.powerUpDuration &lt;= 0) {
        game.powerUpActive = null;
        game.player.speed = 4.5 + (game.skills.speed * 0.75);
        }
        }

        game.enemies.forEach((enemy, index) =&gt; {
        const dx = game.player.x - enemy.x;
        const dy = game.player.y - enemy.y;
        const distance = sqrt(dx * dx + dy * dy);

        enemy.x += (dx / distance) * enemy.speed * deltaTime * 60;
        enemy.y += (dy / distance) * enemy.speed * deltaTime * 60;

        if (distance &lt; game.player.size + enemy.size &amp;&amp; game.player.invulnerable &lt;= 0) {
        let damage = game.level &gt;= 7 ? 8 : game.level &gt;= 4 ? 7 : 6;
        if (game.powerUpActive === 'infallibility') damage = 0;
        game.player.health -= damage * deltaTime * 60;
        game.enemies.splice(index, 1);
        game.player.invulnerable = 30;

        if (game.player.health &lt;= 0) {
        alert('Game Over! Score: ' + game.score);
        location.reload();
        }
        }
        });

        game.projectiles.forEach((proj, projIndex) =&gt; {
        game.enemies.forEach((enemy, enemyIndex) =&gt; {
        const dx = proj.x - enemy.x;
        const dy = proj.y - enemy.y;
        const distance = sqrt(dx * dx + dy * dy);

        if (distance &lt; proj.size + enemy.size) {
        enemy.health -= proj.damage;
        game.projectiles.splice(projIndex, 1);
        createParticles(enemy.x, enemy.y, game.powerUpActive === 'infallibility' ? '#ff4500' : '#ffd700', game.level &gt;= 7 ? 15 : 10, 3, 'cross');

        if (enemy.health &lt;= 0) {
        const particleColor = game.powerUpActive === 'infallibility' ? '#ff4500' : '#ff6b6b';
        const deathParticles = game.level &gt;= 7 ? 20 : game.level &gt;= 4 ? 15 : 10;
        createParticles(enemy.x, enemy.y, particleColor, deathParticles, 3, 'cross');
        game.enemies.splice(enemyIndex, 1);
        const scoreValue = enemy.maxHealth * 8;
        game.score += scoreValue;
        game.xp += scoreValue;
        if (game.level &gt;= 4) {
        game.screenShake = { intensity: 4, duration: 20 };
        }

        if (game.xp &gt;= game.xpNeeded) {
        levelUp();
        }
        }
        }
        });
        });

        game.powerUps.forEach((powerUp, index) =&gt; {
        powerUp.life -= deltaTime * 60;
        if (powerUp.life &lt;= 0) {
        game.powerUps.splice(index, 1);
        }
        });
        }

        game.particles.forEach((particle, index) =&gt; {
        particle.x += particle.vx * deltaTime * 60;
        particle.y += particle.vy * deltaTime * 60;
        particle.life -= deltaTime * 60;

        if (particle.life &lt;= 0) {
        game.particles.splice(index, 1);
        }
        });

        if (game.particles.length &gt; 400) {
        game.particles.splice(0, game.particles.length - 400);
        }

        if (game.skills.healing &gt; 0 &amp;&amp; game.player.health &lt; game.player.maxHealth) {
        const healRate = 0.05 * game.skills.healing;
        game.player.health = Math.min(game.player.maxHealth, game.player.health + healRate * deltaTime * 60);
        if (random() &lt; 0.15) {
        createParticles(game.player.x, game.player.y, '#ff69b4', 5, 3, 'star');
        }
        }

        if (game.level &gt;= 4 &amp;&amp; game.player.health &lt; game.player.maxHealth) {
        game.player.health = Math.min(game.player.maxHealth, game.player.health + 0.05 * deltaTime * 60);
        }

        if (game.skills.speed || game.powerUpActive === 'infallibility') {
        if (input.joystick.active) {
        createParticles(game.player.x, game.player.y, '#ffffff', 5, 3, 'feather');
        }
        }

        updateUI();
        }

        function updateDivineJudgment(deltaTime) {
        game.divineJudgment.timer += deltaTime * 60;
        const level = game.skills.divineJudgment;
        const t = game.divineJudgment.timer / game.divineJudgment.duration;

        if (game.divineJudgment.phase === 'pause') {
        if (t &gt;= 1) {
        game.divineJudgment.phase = 'ascent';
        game.divineJudgment.timer = 0;
        game.divineJudgment.duration = 45;
        }
        } else if (game.divineJudgment.phase === 'ascent') {
        game.player.y = game.player.baseY - 75 * Math.min(t, 1);
        if (t &gt;= 1) {
        game.divineJudgment.phase = 'descent';
        game.divineJudgment.timer = 0;
        game.divineJudgment.duration = 45;
        }
        } else if (game.divineJudgment.phase === 'descent') {
        game.divineJudgment.crossY = game.player.baseY - 150 + 225 * t;
        game.player.y = game.player.baseY - 75;
        createParticles(game.player.x, game.divineJudgment.crossY, '#ffd700', 10, 3, 'cross');
        if (t &gt;= 1) {
        game.divineJudgment.phase = 'impact';
        game.divineJudgment.timer = 0;
        game.divineJudgment.duration = 30;
        game.player.y = game.player.baseY;

        game.enemies.forEach((enemy, index) =&gt; {
        const dx = enemy.x - game.player.x;
        const dy = enemy.y - game.player.y;
        const distance = sqrt(dx * dx + dy * dy);
        const radius = 200 + level * 10;
        if (distance &lt; radius) {
        enemy.health -= game.divineJudgment.damage;
        createParticles(enemy.x, enemy.y, '#ffffff', 20 * level, 3, 'cross');
        if (enemy.health &lt;= 0) {
        createParticles(enemy.x, enemy.y, '#ff4500', 20 * level, 3, 'fire');
        createParticles(enemy.x, enemy.y, '#ff6b6b', 20, 3, 'cross');
        game.enemies.splice(index, 1);
        game.score += enemy.maxHealth * 8;
        game.xp += enemy.maxHealth * 8;
        }
        }
        });

        if (game.level &gt;= 4) {
        game.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        game.ctx.fillRect(0, 0, game.width, game.height);
        }
        const rumble = game.level &gt;= 7 ? 16 : game.level &gt;= 4 ? 12 : 8;
        game.screenShake = { intensity: rumble, duration: 80 };
        }
        } else if (game.divineJudgment.phase === 'impact') {
        if (game.divineJudgment.timer &gt;= game.divineJudgment.duration) {
        game.divineJudgment = null;
        }
        }
        }

        function updateMichael(deltaTime) {
        if (!game.michael) return;
        game.michael.duration = (game.michael.duration || 360);
        game.michael.duration -= deltaTime * 60;
        if (game.enemies.length === 0 || game.michael.duration &lt;= 0) {
        game.michael = null;
        game.powerUpActive = null;
        return;
        }
        if (!game.michael.target &amp;&amp; game.enemies.length &gt; 0) {
        let closestEnemy = null;
        let closestDistance = Infinity;
        game.enemies.forEach(enemy =&gt; {
        const dx = enemy.x - game.michael.x;
        const dy = enemy.y - game.michael.y;
        const distance = sqrt(dx * dx + dy * dy);
        if (distance &lt; closestDistance) {
        closestDistance = distance;
        closestEnemy = enemy;
        }
        });
        game.michael.target = closestEnemy;
        game.michael.attackTimer = 100;
        }
        if (game.michael.target) {
        const dx = game.michael.target.x - game.michael.x;
        const dy = game.michael.target.y - game.michael.y;
        const distance = sqrt(dx * dx + dy * dy);
        const speed = 25 * deltaTime * 60;
        if (distance &gt; 10) {
        game.michael.x += (dx / distance) * speed;
        game.michael.y += (dy / distance) * speed;
        game.michael.x = Math.max(20, Math.min(game.width - 20, game.michael.x));
        game.michael.y = Math.max(20, Math.min(game.height - 20, game.michael.y));
        createParticles(game.michael.x, game.michael.y, '#ffd700', game.level &gt;= 7 ? 15 : 10, 3, 'cross');
        } else {
        game.enemies.forEach((enemy, index) =&gt; {
        const dx = enemy.x - game.michael.x;
        const dy = enemy.y - game.michael.y;
        const distance = sqrt(dx * dx + dy * dy);
        if (distance &lt; 150) {
        enemy.health -= 4;
        createParticles(enemy.x, enemy.y, '#ffffff', game.level &gt;= 7 ? 25 : 15, 3, 'cross');
        if (enemy.health &lt;= 0) {
        createParticles(enemy.x, enemy.y, '#ff6b6b', game.level &gt;= 7 ? 35 : 20, 3, 'cross');
        game.enemies.splice(index, 1);
        game.score += enemy.maxHealth * 8;
        game.xp += enemy.maxHealth * 8;
        if (game.level &gt;= 4) {
        game.screenShake = { intensity: 6, duration: 30 };
        }
        }
        }
        });
        game.michael.target = null;
        }
        }
        }

        function shootAtClosest() {
        if (game.enemies.length === 0 || game.divineJudgment &amp;&amp; game.divineJudgment.phase !== 'impact') return;

        let closestEnemy = null;
        let closestDistance = Infinity;

        game.enemies.forEach(enemy =&gt; {
        const dx = enemy.x - game.player.x;
        const dy = enemy.y - game.player.y;
        const distance = sqrt(dx * dx + dy * dy);

        if (distance &lt; closestDistance) {
        closestDistance = distance;
        closestEnemy = enemy;
        }
        });

        if (closestEnemy) {
        const dx = closestEnemy.x - game.player.x;
        const dy = closestEnemy.y - game.player.y;
        const angle = atan2(dy, dx);

        const shots = game.skills.multishot ? Math.floor(1 + game.skills.multishot * 0.5) : 1;
        const angleSpread = game.skills.multishot ? 0.3 : 0;
        const baseSize = game.level &gt;= 7 ? 5 : game.level &gt;= 4 ? 4.5 : 4;
        const baseDamage = game.level &gt;= 7 ? 1 : game.level &gt;= 4 ? 0.875 : 0.75;

        for (let i = 0; i &lt; shots; i++) {
        const shotAngle = angle + (i - (shots - 1) / 2) * angleSpread;
        const projectile = {
        x: game.player.x,
        y: game.player.y,
        angle: shotAngle,
        speed: 10,
        size: game.skills.summa ? baseSize * (1 + game.skills.summa * 0.125) : baseSize,
        damage: game.powerUpActive === 'infallibility' ? Infinity : baseDamage * (game.skills.damage ? 1 + game.skills.damage * 0.25 : 1)
        };
        game.projectiles.push(projectile);
        }
        }
        }

        function spawnPowerUp() {
        const types = ['infallibility', 'michael'];
        const type = types[Math.floor(random() * types.length)];

        const powerUp = {
        x: random() * (game.width - 100) + 50,
        y: random() * (game.height - 100) + 50,
        type: type,
        size: 15,
        life: 600
        };

        game.powerUps.push(powerUp);
        }

        function activatePowerUp(type) {
        game.powerUpActive = type;
        game.powerUpDuration = type === 'michael' ? 0 : 540;

        game.screenShake = { intensity: 10, duration: 60 };
        createParticles(game.player.x, game.player.y, '#ffd700', 50, 3, 'cross');

        let textColor;
        switch(type) {
        case 'infallibility':
        game.player.speed += 12;
        createParticles(game.player.x, game.player.y, '#ffffff', 80, 3, 'cross');
        game.ctx.fillStyle = 'rgba(255,255,255,0.8)';
        game.ctx.fillRect(0, 0, game.width, game.height);
        textColor = '#ffffff';
        addTextOverlay('Papal Infallibility! +12 Speed, One-Shot Kills', textColor);
        break;
        case 'michael':
        game.michael = {
        x: game.player.x,
        y: game.player.y,
        target: null,
        attackTimer: 0,
        duration: 360
        };
        createParticles(game.player.x, game.player.y, '#ffd700', 60, 3, 'cross');
        game.ctx.fillStyle = 'rgba(255,255,255,0.7)';
        game.ctx.fillRect(0, 0, game.width, game.height);
        textColor = '#ffd700';
        addTextOverlay('St. Michael‚Äôs Wrath! 4 DMG AoE', textColor);
        break;
        }
        }

        function spawnEnemy() {
        const side = Math.floor(random() * 4);
        let x, y;

        switch(side) {
        case 0: x = random() * game.width; y = -20; break;
        case 1: x = game.width + 20; y = random() * game.height; break;
        case 2: x = random() * game.width; y = game.height + 20; break;
        case 3: x = -20; y = random() * game.height; break;
        }

        const enemyTypes = [
        { symbol: '‚õ§', health: 2, speed: 1.1, size: 12 },
        { symbol: 'üëπ', health: 4, speed: 0.9, size: 15 },
        { symbol: 'üî•', health: 2, speed: 1.5, size: 10 },
        { symbol: 'üíÄ', health: 6, speed: 0.75, size: 18 },
        { symbol: 'üêç', health: 4, speed: 1.3, size: 14 },
        { symbol: '‚ò†Ô∏è', health: 8, speed: 0.6, size: 16 },
        { symbol: '‚ö°', health: 3, speed: 2, size: 8 },
        { symbol: 'ü¶ã', health: 5, speed: 1, size: 13 }
        ];

        let enemyType;
        const rand = random();
        if (game.level &lt;= 3) {
        enemyType = enemyTypes[Math.floor(rand * 5)];
        } else if (game.level &lt;= 5) {
        enemyType = enemyTypes[Math.floor(rand * 6)];
        } else {
        enemyType = enemyTypes[Math.floor(rand * enemyTypes.length)];
        }

        const healthScale = game.level &lt;= 3 ? 1 + game.level * 0.08 : 1 + game.level * 0.12;
        const enemy = {
        x: x,
        y: y,
        size: enemyType.size,
        speed: enemyType.speed * (game.skills.holyWater ? 1 - (0.05 + game.skills.holyWater * 0.05) : 1),
        health: enemyType.health * healthScale,
        maxHealth: enemyType.health * healthScale,
        symbol: enemyType.symbol,
        glow: game.skills.holyWater ? '#00b7eb' : null
        };

        game.enemies.push(enemy);
        }

        function createParticles(x, y, color, count = 5, size = 3, shape = 'cross') {
        const symbols = {
        droplet: 'üíß',
        book: 'üìñ',
        bead: 'üî¥',
        heart: '‚úùÔ∏è',
        sword: 'üî•',
        trident: 'üî±',
        star: '‚ú®',
        cross: '‚úùÔ∏è',
        fire: 'üî•'
        };
        for (let i = 0; i &lt; count; i++) {
        const particle = {
        x: x,
        y: y,
        vx: (random() - 0.5) * 8,
        vy: (random() - 0.5) * 8,
        life: 30,
        color: color,
        size: size,
        shape: symbols[shape] || shape
        };
        game.particles.push(particle);
        }
        }

        function levelUp() {
        game.level++;
        game.xp = 0;
        game.xpNeeded = game.level &lt;= 3 ? 150 + game.level * 75 : game.level * 150;
        game.skillPoints++;
        const particleCount = game.level &gt;= 7 ? 30 : game.level &gt;= 4 ? 25 : 20;
        createParticles(game.player.x, game.player.y, '#ffd700', particleCount, 3, 'cross');
        addTextOverlay('Level Up! Point Added', '#ffd700');
        }

        function updateUI() {
        document.getElementById('health').textContent = Math.round(game.player.health);
        document.getElementById('score').textContent = game.score;
        document.getElementById('level').textContent = game.level;
        document.getElementById('xp').textContent = game.xp;
        document.getElementById('xpNeeded').textContent = game.xpNeeded;
        document.getElementById('classLevel').textContent = game.classLevel;
        document.getElementById('availablePoints').textContent = game.skillPoints;
        }

        function render() {
        try {
        game.ctx.save();
        console.log('Rendering frame:', { player: game.player, enemies: game.enemies.length });

        if (game.screenShake.intensity &gt; 0) {
        const offsetX = (random() - 0.5) * game.screenShake.intensity;
        const offsetY = (random() - 0.5) * game.screenShake.intensity;
        game.ctx.translate(offsetX, offsetY);
        }

        game.ctx.fillStyle = '#1a0f0a';
        game.ctx.fillRect(0, 0, game.width, game.height);

        if (game.divineJudgment &amp;&amp; game.divineJudgment.phase === 'pause') {
        game.ctx.fillStyle = 'rgba(255,255,255,0.3)';
        game.ctx.fillRect(0, 0, game.width, game.height);
        game.ctx.fillStyle = 'rgba(0,0,0,0.5)';
        game.ctx.fillRect(0, 0, game.width, 50);
        game.ctx.fillRect(0, game.height - 50, game.width, 50);
        game.ctx.fillRect(0, 0, 50, game.height);
        game.ctx.fillRect(game.width - 50, 0, 50, game.height);
        }

        if (game.startupMessage) {
        game.ctx.save();
        game.ctx.globalAlpha = game.startupMessage.life / 120;
        game.ctx.fillStyle = '#ffd700';
        game.ctx.font = '20px Arial';
        game.ctx.textAlign = 'center';
        game.ctx.textBaseline = 'middle';
        game.ctx.fillText(game.startupMessage.text, game.centerX, game.centerY);
        game.ctx.restore();
        }

        game.ctx.font = '20px Arial';
        game.ctx.textAlign = 'center';
        game.ctx.textBaseline = 'middle';
        game.textOverlays.forEach(overlay =&gt; {
        game.ctx.save();
        game.ctx.globalAlpha = overlay.opacity;
        game.ctx.fillStyle = overlay.color;
        game.ctx.font = `${20 * overlay.scale}px Arial`;
        game.ctx.fillText(overlay.text, overlay.x, overlay.y);
        game.ctx.restore();
        });

        game.ctx.save();
        game.ctx.beginPath();
        game.ctx.rect(0, 0, game.width, game.height);
        game.ctx.clip();
        game.particles.forEach(particle =&gt; {
        if (particle.x &lt; 0 || particle.x &gt; game.width || particle.y &lt; 0 || particle.y &gt; game.height) return;
        game.ctx.save();
        game.ctx.translate(particle.x, particle.y);
        game.ctx.globalAlpha = particle.life / 30;
        game.ctx.fillStyle = particle.color;
        game.ctx.font = `${particle.size * 2}px Arial`;
        game.ctx.textAlign = 'center';
        game.ctx.fillText(particle.shape, 0, particle.size);
        game.ctx.restore();
        });
        game.ctx.restore();

        if (game.michael) {
        game.ctx.save();
        game.ctx.translate(game.michael.x, game.michael.y);
        game.ctx.fillStyle = 'rgba(255,215,0,0.6)';
        game.ctx.beginPath();
        game.ctx.arc(0, 0, 40, 0, TWO_PI);
        game.ctx.fill();

        game.ctx.shadowColor = '#ffffff';
        game.ctx.shadowBlur = 30;

        game.ctx.fillStyle = '#ffffff';
        game.ctx.font = '50px Arial';
        game.ctx.textAlign = 'center';
        game.ctx.fillText('‚öîÔ∏è', 0, 10);

        game.ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        game.ctx.lineWidth = 5;
        game.ctx.beginPath();
        game.ctx.moveTo(-30, 0);
        game.ctx.quadraticCurveTo(0, -35, 30, 0);
        game.ctx.stroke();
        game.ctx.beginPath();
        game.ctx.moveTo(-30, 0);
        game.ctx.quadraticCurveTo(0, 35, 30, 0);
        game.ctx.stroke();

        game.ctx.restore();
        }

        game.ctx.save();
        game.ctx.translate(game.player.x, game.player.y);
        console.log('Drawing player at:', { x: game.player.x, y: game.player.y });

        const pulseScale = game.player.pulse &gt; 0 ? 1 + 0.3 * (game.player.pulse / 12) : 1;
        game.ctx.scale(pulseScale, pulseScale);

        if (game.divineJudgment &amp;&amp; game.divineJudgment.phase !== 'impact') {
        const pulse = 0.5 + 0.3 * Math.sin(game.divineJudgment.timer * 0.1);
        game.ctx.fillStyle = `rgba(255,255,255,${pulse})`;
        game.ctx.beginPath();
        game.ctx.arc(0, 0, 50, 0, TWO_PI);
        game.ctx.fill();
        }

        if (game.powerUpActive &amp;&amp; !game.michael) {
        game.ctx.strokeStyle = 'rgba(255,215,0,0.6)';
        game.ctx.lineWidth = 5;
        for (let i = 0; i &lt; 10; i++) {
        const angle = (i / 10) * TWO_PI;
        game.ctx.beginPath();
        game.ctx.moveTo(0, 0);
        game.ctx.lineTo(cos(angle) * 40, sin(angle) * 40);
        game.ctx.stroke();
        }

        game.ctx.strokeStyle = '#ffd700';
        game.ctx.lineWidth = 6;
        game.ctx.beginPath();
        game.ctx.arc(0, -20, 30, 0, TWO_PI);
        game.ctx.stroke();

        if (game.powerUpActive === 'infallibility') {
        game.ctx.fillStyle = 'rgba(255,255,255,0.5)';
        game.ctx.beginPath();
        game.ctx.arc(0, 0, 35, 0, TWO_PI);
        game.ctx.fill();
        }
        }

        if (game.skills.speed || game.skills.damage || game.skills.rosary || game.skills.multishot) {
        game.ctx.fillStyle = 'rgba(255,215,0,0.5)';
        game.ctx.beginPath();
        game.ctx.arc(0, 0, 35, 0, TWO_PI);
        game.ctx.fill();
        }

        game.ctx.fillStyle = '#ffffff';
        game.ctx.fillRect(-10, -5, 20, 15);

        game.ctx.fillStyle = '#ffd700';
        game.ctx.beginPath();
        game.ctx.moveTo(-12, -8);
        game.ctx.lineTo(12, -8);
        game.ctx.lineTo(8, -20);
        game.ctx.lineTo(-8, -20);
        game.ctx.closePath();
        game.ctx.fill();

        game.ctx.beginPath();
        game.ctx.moveTo(-8, -20);
        game.ctx.lineTo(0, -28);
        game.ctx.lineTo(8, -20);
        game.ctx.closePath();
        game.ctx.fill();

        game.ctx.fillStyle = '#ffffff';
        game.ctx.fillRect(-10, -12, 20, 2);

        game.ctx.fillRect(-1, -25, 2, 8);
        game.ctx.fillRect(-4, -22, 8, 2);

        game.ctx.restore();

        if (game.divineJudgment &amp;&amp; game.divineJudgment.phase === 'descent') {
        game.ctx.save();
        game.ctx.translate(game.player.x, game.divineJudgment.crossY);
        const gradient = game.ctx.createRadialGradient(0, 0, 0, 0, 0, 100);
        gradient.addColorStop(0, 'rgba(255,215,0,0.8)');
        gradient.addColorStop(1, 'rgba(255,215,0,0)');
        game.ctx.globalCompositeOperation = 'lighter';
        game.ctx.fillStyle = gradient;
        game.ctx.beginPath();
        game.ctx.arc(0, 0, 100, 0, TWO_PI);
        game.ctx.fill();
        game.ctx.globalCompositeOperation = 'source-over';
        game.ctx.fillStyle = '#ffffff';
        game.ctx.font = '75px Arial';
        game.ctx.textAlign = 'center';
        game.ctx.fillText('‚úùÔ∏è', 0, 0);
        game.ctx.restore();
        }

        if (game.divineJudgment &amp;&amp; game.divineJudgment.phase === 'impact') {
        game.ctx.save();
        game.ctx.translate(game.player.x, game.player.y);
        const t = game.divineJudgment.timer / game.divineJudgment.duration;
        for (let i = 0; i &lt; 3; i++) {
        const radius = (50 + i * 75) * t;
        game.ctx.strokeStyle = `rgba(255,${255 - i * 50},${255 - i * 100},${1 - t})`;
        game.ctx.lineWidth = 5;
        game.ctx.beginPath();
        game.ctx.arc(0, 0, radius, 0, TWO_PI);
        game.ctx.stroke();
        }
        game.ctx.restore();
        }

        game.projectiles.forEach(proj =&gt; {
        game.ctx.save();
        game.ctx.translate(proj.x, proj.y);
        let color = '#ffd700';
        let symbol = '‚úû';
        if (game.skills.rosary) {
        symbol = 'üìø';
        }
        if (game.powerUpActive === 'infallibility') {
        color = '#ffffff';
        symbol = 'üåü';
        }
        game.ctx.fillStyle = color;
        game.ctx.font = `${proj.size * 2}px Arial`;
        game.ctx.textAlign = 'center';
        game.ctx.fillText(symbol, 0, proj.size);
        game.ctx.restore();
        });

        game.powerUps.forEach(powerUp =&gt; {
        game.ctx.save();
        game.ctx.shadowColor = '#ffd700';
        game.ctx.shadowBlur = 20;

        game.ctx.fillStyle = '#ffd700';
        game.ctx.font = '35px Arial';
        game.ctx.textAlign = 'center';

        let symbol = '';
        let name = '';
        switch(powerUp.type) {
        case 'infallibility': symbol = 'üåü'; name = 'Papal Infallibility'; break;
        case 'michael': symbol = '‚öîÔ∏è'; name = 'St. Michael‚Äôs Wrath'; break;
        }

        game.ctx.fillText(symbol, powerUp.x, powerUp.y + 8);

        game.ctx.font = '12px Arial';
        game.ctx.fillStyle = '#ffffff';
        game.ctx.fillText(name, powerUp.x, powerUp.y + 30);

        game.ctx.restore();
        });

        game.enemies.forEach(enemy =&gt; {
        console.log('Drawing enemy:', { x: enemy.x, y: enemy.y, symbol: enemy.symbol });
        if (enemy.maxHealth &gt; 1) {
        const barWidth = 20;
        const barHeight = 3;
        const healthPercent = enemy.health / enemy.maxHealth;

        game.ctx.fillStyle = '#333';
        game.ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size - 8, barWidth, barHeight);

        game.ctx.fillStyle = '#ff3333';
        game.ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size - 8, barWidth * healthPercent, barHeight);
        }

        game.ctx.fillStyle = enemy.glow || '#ff3333';
        game.ctx.shadowColor = enemy.glow || '#ff3333';
        game.ctx.shadowBlur = enemy.glow ? 15 : 0;
        game.ctx.font = `${enemy.size + 5}px Arial`;
        game.ctx.textAlign = 'center';
        game.ctx.fillText(enemy.symbol, enemy.x, enemy.y + enemy.size/2);
        game.ctx.shadowBlur = 0;

        if (!enemy.symbol) {
        game.ctx.fillStyle = 'red';
        game.ctx.fillRect(enemy.x - 2, enemy.y - 2, 4, 4);
        }
        });

        if (!game.player.x || !game.player.y) {
        game.ctx.fillStyle = 'red';
        game.ctx.fillRect(game.centerX - 2, game.centerY - 2, 4, 4);
        }

        game.ctx.restore();
        } catch (e) {
        console.error('Render error:', e);
        }
        }

        function gameLoop(timestamp = performance.now()) {
        try {
        update(timestamp);
        render();
        } catch (e) {
        console.error('Game loop error:', e);
        }
        requestAnimationFrame(gameLoop);
        }

        init();
        &lt;/script&gt;
        &lt;/body&gt;
        &lt;/html&gt;</pre>
</body>
</html>